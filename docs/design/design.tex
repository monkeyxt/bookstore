\documentclass[11pt,]{article}
\usepackage[left=1in,top=1in,right=1in,bottom=1in]{geometry}
\newcommand*{\authorfont}{\fontfamily{phv}\selectfont}
\usepackage[]{mathpazo}


  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}




\usepackage{abstract}
\renewcommand{\abstractname}{}    % clear the title
\renewcommand{\absnamepos}{empty} % originally center

\renewenvironment{abstract}
 {{%
    \setlength{\leftmargin}{0mm}
    \setlength{\rightmargin}{\leftmargin}%
  }%
  \relax}
 {\endlist}

\makeatletter
\def\@maketitle{%
  \newpage
%  \null
%  \vskip 2em%
%  \begin{center}%
  \let \footnote \thanks
    {\fontsize{18}{20}\selectfont\raggedright  \setlength{\parindent}{0pt} \@title \par}%
}
%\fi
\makeatother




\setcounter{secnumdepth}{0}

\usepackage{longtable,booktabs}



\title{CS 677 Lab 3 Design Report  }



\author{\Large Dan Cline, Kyle Stevens, Tian Xia\vspace{0.05in} \newline\normalsize\emph{UMass Amherst, Amherst College}  }


\date{}

\usepackage{titlesec}

\titleformat*{\section}{\normalsize\bfseries}
\titleformat*{\subsection}{\normalsize\itshape}
\titleformat*{\subsubsection}{\normalsize\itshape}
\titleformat*{\paragraph}{\normalsize\itshape}
\titleformat*{\subparagraph}{\normalsize\itshape}


\usepackage{natbib}
\bibliographystyle{apsr}
\usepackage[strings]{underscore} % protect underscores in most circumstances



\newtheorem{hypothesis}{Hypothesis}
\usepackage{setspace}


% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usepackage{hyperref}
\usepackage{graphicx}

% move the hyperref stuff down here, after header-includes, to allow for - \usepackage{hyperref}

\makeatletter
\@ifpackageloaded{hyperref}{}{%
\ifxetex
  \PassOptionsToPackage{hyphens}{url}\usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \PassOptionsToPackage{hyphens}{url}\usepackage[draft,unicode=true]{hyperref}
\fi
}

\@ifpackageloaded{color}{
    \PassOptionsToPackage{usenames,dvipsnames}{color}
}{%
    \usepackage[usenames,dvipsnames]{color}
}
\makeatother
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Dan Cline, Kyle Stevens, Tian Xia (UMass Amherst, Amherst College)},
             pdfkeywords = {},  
            pdftitle={CS 677 Lab 3 Design Report},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls

% Add an option for endnotes. -----


% add tightlist ----------
\providecommand{\tightlist}{%
\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

% add some other packages ----------

% \usepackage{multicol}
% This should regulate where figures float
% See: https://tex.stackexchange.com/questions/2275/keeping-tables-figures-close-to-where-they-are-mentioned
\usepackage[section]{placeins}


\begin{document}
	
% \pagenumbering{arabic}% resets `page` counter to 1 
%
% \maketitle

{% \usefont{T1}{pnc}{m}{n}
\setlength{\parindent}{0pt}
\thispagestyle{plain}
{\fontsize{18}{20}\selectfont\raggedright 
\maketitle  % title \par  

}

{
   \vskip 13.5pt\relax \normalsize\fontsize{11}{12} 
\textbf{\authorfont Dan Cline, Kyle Stevens, Tian Xia} \hskip 15pt \emph{\small UMass Amherst, Amherst College}   

}

}








\begin{abstract}

    \hbox{\vrule height .2pt width 39.14pc}

    \vskip 8.5pt % \small 

\noindent This document provides information of how our multi-tier web system was
designed, the trade-offs involved with our implementation and future
improvements that may be made on the system.


    \hbox{\vrule height .2pt width 39.14pc}


\end{abstract}


\vskip -8.5pt


 % removetitleabstract

\noindent  

\hypertarget{overview-of-the-system}{%
\section{Overview of the System}\label{overview-of-the-system}}

We used the Python Flask library to implement a web framework with REST
APIs. Each server would be initialized with their own \texttt{ip} and
\texttt{port} by reading in the configurations from \texttt{config.yml}.
Each server is also aware of the addresses of other servers through the
same config file. The order server and the catalog server dumps their
logs in the local \texttt{log} directory. There are five servers in
operation: 2 catalog servers, 2 order servers and 1 frontend server. In
terms of replication, we used the primary-write scheme. The frontend
uses a random load balancing scheme while we fixed server
\texttt{order1} to talk with \texttt{catalog1} and \texttt{order2} talks
with \texttt{catalog2}. The item configurations are agreed on by all
components pre-specified in the catalog server in an internal data
structure:

\begin{longtable}[]{@{}lllll@{}}
\toprule
book & item\_number & topic & stock & price\tabularnewline
\midrule
\endhead
``How to get a good grade in 677 in 20 minutes a day'' & 1 & systems &
1011 & 3\tabularnewline
``RPC for Dummies'' & 2 & systems & 1007 & 4\tabularnewline
``Xen and the Art of Surviving Graduate School'' & 3 & gradschool & 1002
& 15\tabularnewline
``Cooking for the Impatient Graduate Student'' & 4 & gradschool & 1100 &
5\tabularnewline
``How to finish Project 3 on time'' & 5 & gradschool & 100 &
1\tabularnewline
``Why theory classes are so hard'' & 6 & systems & 20 & 2\tabularnewline
``Spring in the Pioneer Valley'' & 7 & gradschool & 50 &
3\tabularnewline
\bottomrule
\end{longtable}

\noindent In terms of specific implementation, we followed the component
structure and interfaces as given in the lab specification. Below, we
describe in details each component and how each component accomplishes
its intended functions, as well as additional features.

\hypertarget{client}{%
\subsection{Client:}\label{client}}

The client connects to the frontend server and uses the functions
exposed by the frontend server to perform \texttt{buy}, \texttt{search}
and \texttt{lookup} requests.

\hypertarget{frontend-server}{%
\subsection{Frontend Server:}\label{frontend-server}}

This server has three functions: \texttt{search(topic)},
\texttt{lookup(item\_number)} and \texttt{buy(item\_number)}. Each
function redirects the client to the appropriate server, waits for the
results and parse the the \texttt{json} request in a nicely formatted
string to return to the client. Caching is implemented by storing the
previously queried result in a dictionary, using the item numbers or
topic name as key and \texttt{Json} as value.

If the catalog server is ever updated, the catalog server sends an
invalidation request and deletes the key from the local cache. For load
balancing, the frontend server randomly picks a server from the list of
available servers and sends a request. If the request fails to go
through, the frontend server just tries to pick another random server
and hopes that the requests go through.

\hypertarget{order-server}{%
\subsection{Order Server:}\label{order-server}}

There are two replicas of the order server: one primary and one
secondary. Each server is assigned an integer ID and the primary is
always the alive server with the highest ID. The order server exposes
the \texttt{buy(item\_id)} function which is responsible for querying
the catalog server for the current stock number of the desired item. If
the stock number is 0, the buy request fails and returns a failure
message to the client. Otherwise, the order server sends a update
RESTful request to the catalog server.

When both replicas are running, replica 1 is assigned as the primary. If
a server crash occurs, the surviving replica is designated at the
primary and as soon as the second replica comes back online, it
multicasts to both replicas that the primary is now assigned to replica
1, since now replica 1 must be online.

If the server is a secondary server, it forwards the request to the
primary server for the primary to execute locally. Once the request is
executed locally, the primary forwards the request to the secondary
server, telling the secondary to sync the same update as the primary
using the \texttt{/sync} endpoint. Both servers write logs of orders
into a local database. If the server crashes, it tries to replicate the
database of the other server to stay in sync by using the
\texttt{/download} endpoint. An example buy request and json result is
as below:

\begin{verbatim}
/buy/1

{
  "status": true,
  "processing_time": 0.01
}
\end{verbatim}

\hypertarget{catalog-server}{%
\subsection{Catalog Server:}\label{catalog-server}}

There are two replicas of the catalog server: one primary and one
secondary. Each server is assigned an integer ID and the primary is
always the alive server with the highest ID. The catalog server exposes
two functions: \texttt{query()} and \texttt{update}, which has root URLs
\texttt{/query} and \texttt{/update}. The query function allows querying
by topic string and item number integers, and returns book details. The
update function reads the update API call sent by the order server,
locks the item database and catalog log, and returns a success message
if the update function is performed correctly.

Replication and fault tolerance is implemented in a similar manner as
the order server. The only difference is that when the crashed server
wakes up from the crash, it downloads from the alive server both the
database and the internal data structure. Examples of querying and
updating request are as below:

\begin{verbatim}
/query/1
{
  "How to get a good grade in 677 in 20 minutes a day": {
    "item_number": 1,
    "price": 3,
    "stock": 11,
    "topic": 'systems'
  }
}

/query/systems
{
  "How to get a good grade in 677 in 20 minutes a day": {
    "item_number": 1,
    "price": 3,
    "stock": 11,
    "topic": 'systems'
  },
  "RPC for Dummies" : {
    "item_number": 2,
    "price": 4,
    "stock": 5,
    "topic": 'systems'
  }
}

/update/<item_number>/<attribute>/<operation>/<int:number>
{"status": True}
\end{verbatim}

\hypertarget{design-trade-offs}{%
\section{Design Trade-offs}\label{design-trade-offs}}

For the ease of implementation we hardcoded the address and port of each
server on startup. This could be a problem if we want to move the
resource of one of the server around, since the other components would
lose track of the server address. We also only used one lock to handle
updates in the catalog database. Although this is easier to code, it can
be inefficient since even buying a different item would require the lock
to be released on the item the catalog serve is currently updating.

\hypertarget{future-improvements}{%
\section{Future Improvements}\label{future-improvements}}

Because of time constraints, there are several features that we did not
implement but would like to have included.

\begin{itemize}
\item
  One possible extension would be to able to buy multiple items at the
  same time. This makes more intuitive sense from an online store
  perspective. The update function in the order server can already
  handle multiple item buy requests and only the frontend need to be
  updated to expose the function.
\item
  We could have made the system more expandable by introducing a leader
  election algorithm that would work with 3 or more replicas. The
  current system does not need a leader election algorithm since only
  two servers are involved.
\item
  Another possible extention would be inplementing some kind of cache
  replacement algorithms for the frontend cache like LRU so that for a
  limited amount of cache memory, we can optimize the cache hit
  frequency.
\end{itemize}

\hypertarget{how-to-run}{%
\section{How to Run}\label{how-to-run}}

To run all the designed tests, navigate to the \texttt{tests} folder and

\begin{verbatim}
# for remote testing
$ bash run_all.sh
\end{verbatim}

\noindent To terminate the process on all machines, send \texttt{ctrl+c}
to the script and it will terminate all running pids of node instances
on each remote machine. \newline

\noindent To run the program in general, navigate to the \texttt{tests}
folder, specify the desired ip address and port number in
\texttt{config.yml} and run

\begin{verbatim}
# setting up the server
$ bash run.sh
\end{verbatim}

\noindent To run the local client to perform functions on the remote
servers, run \texttt{python3\ client.py}

\begin{verbatim}
# Normal client functions
$ python3 client.py buy <item_id>
$ python3 client.py lookup <item_id>
$ python3 client.py search <topic>

# Sequential requests
$ python3 client.py lookup <item_id> <iterations>

# Write average time to file
$ python3 client.py lookup <item_id> <iterations> <client_id>
\end{verbatim}

\noindent If the program is run locally output logs for each server will
be dumped in the working directory. If the program is run remotely, logs
for each server is dumped on the machine it is running on. \texttt{ssh}
into different machines to view the output logs.





\newpage
\singlespacing 
\bibliography{master.bib}

\end{document}
